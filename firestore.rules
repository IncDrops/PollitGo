
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(resourceId) {
      return request.auth.uid == resourceId;
    }

    function getPoll(pollId) {
      return get(/databases/$(database)/documents/polls/$(pollId)).data;
    }

    function isPollCreator(pollId) {
      return isAuthenticated() && getPoll(pollId).creator.id == request.auth.uid;
    }

    function isCommentAuthor(commentId) {
      return isAuthenticated() && get(/databases/$(database)/documents/comments/$(commentId)).data.user.id == request.auth.uid;
    }

    function pollDeadlinePassed(pollId) {
        let poll = getPoll(pollId);
        return poll.deadline != null && request.time > timestamp. έχουν(poll.deadline);
    }

    // User Profiles
    // Path: /users/{userId}
    match /users/{userId} {
      // Anyone can read user profiles (e.g., to display names, avatars)
      allow read: if true;

      // Only an authenticated user can create their own profile document
      // Typically done during signup
      allow create: if isAuthenticated() && isOwner(userId)
                    && request.resource.data.id == userId // Ensure ID consistency
                    && request.resource.data.username is string
                    && request.resource.data.username.size() >= 3
                    && request.resource.data.username.size() <= 20
                    && request.resource.data.email == request.auth.token.email // Email matches auth token
                    && request.resource.data.createdAt == request.time // Server timestamp for creation
                    && (!('pollitPointsBalance' in request.resource.data) || request.resource.data.pollitPointsBalance == 0)
                    && request.resource.data.keys().hasOnly(['id', 'username', 'email', 'avatarUrl', 'createdAt', 'pollitPointsBalance', 'bio', 'location', 'website']); // Enforce allowed fields


      // Only the owner can update their own profile
      // They cannot change their email (usually), id, or createdAt via update
      // They can update username, avatarUrl, bio, location, website
      // pollitPointsBalance should be updated by backend functions, not directly by user.
      allow update: if isAuthenticated() && isOwner(userId)
                    && request.resource.data.id == userId // ID cannot change
                    && request.resource.data.email == resource.data.email // Email cannot change
                    && request.resource.data.createdAt == resource.data.createdAt // createdAt cannot change
                    && (!('pollitPointsBalance' in request.resource.data) || request.resource.data.pollitPointsBalance == resource.data.pollitPointsBalance) // User cannot directly change points
                    && (!('username' in request.resource.data) || (request.resource.data.username is string && request.resource.data.username.size() >= 3 && request.resource.data.username.size() <= 20))
                    && request.resource.data.keys().hasOnly(['id', 'username', 'email', 'avatarUrl', 'createdAt', 'pollitPointsBalance', 'bio', 'location', 'website']); // Enforce allowed fields

      // Users cannot delete their own profiles directly (handle via backend function if needed)
      allow delete: if false;
    }

    // Polls
    // Path: /polls/{pollId}
    match /polls/{pollId} {
      // Anyone can read polls
      allow read: if true;

      // Authenticated users can create polls
      allow create: if isAuthenticated()
                    && request.resource.data.creator.id == request.auth.uid // Creator ID matches authenticated user
                    && request.resource.data.question is string && request.resource.data.question.size() > 0 && request.resource.data.question.size() < 300
                    && request.resource.data.options is list && request.resource.data.options.size() >= 2 && request.resource.data.options.size() <= 4
                    && request.resource.data.options[0].text is string // Basic check, can be more detailed per option
                    && request.resource.data.deadline is timestamp && request.resource.data.deadline > request.time // Deadline must be in future
                    && request.resource.data.createdAt == request.time // Server timestamp
                    && request.resource.data.totalVotes == 0
                    && request.resource.data.likes == 0
                    && request.resource.data.commentsCount == 0
                    && (!('pledgeAmount' in request.resource.data) || (request.resource.data.pledgeAmount is number && request.resource.data.pledgeAmount >= 0.50))
                    && (!('pledgeOutcome' in request.resource.data) || request.resource.data.pledgeOutcome == 'pending' || request.resource.data.pledgeOutcome == null)
                    && request.resource.data.isSpicy is bool
                    && request.resource.data.keys().hasOnly([
                        'creator', 'question', 'options', 'imageUrls', 'imageKeywords', 'videoUrl',
                        'deadline', 'createdAt', 'totalVotes', 'likes', 'commentsCount',
                        'pledgeAmount', 'pledgeOutcome', 'tipCount', 'isSpicy', 'id' // Add 'id' if you plan to store it in doc
                    ]);


      // Poll creator can update pledgeOutcome after deadline. Other updates might be restricted or handled differently.
      // Likes and commentsCount are usually updated via transactions or backend.
      // Votes are handled by a separate 'votes' subcollection or a transaction.
      allow update: if isAuthenticated() && isPollCreator(pollId)
                    // Allow updating pledgeOutcome if deadline passed and it was pending
                    && (
                        request.resource.data.pledgeOutcome != resource.data.pledgeOutcome &&
                        (resource.data.pledgeOutcome == 'pending' || resource.data.pledgeOutcome == null) &&
                        (request.resource.data.pledgeOutcome == 'accepted' || request.resource.data.pledgeOutcome == 'tipped_crowd') &&
                        pollDeadlinePassed(pollId) &&
                        // Ensure only pledgeOutcome is changing or other allowed fields
                        request.resource.data.keys().hasOnly(resource.data.keys().concat(['pledgeOutcome'])) &&
                        request.resource.data.question == resource.data.question // Example: question cannot change
                    )
                    // Add rules for other updatable fields like 'likes' if handled by client (ensure secure increments)
                    // Example for likes (better with transactions/backend):
                    // || (request.resource.data.likes == resource.data.likes + 1)

                    // For now, highly restrict direct updates to polls by users, favor backend logic
                    // This is a placeholder, expand based on what needs to be client-updatable
                    && false; // Default to false for other updates for now

      // Only poll creator can delete their poll (consider implications, e.g., orphaned votes/comments)
      allow delete: if isAuthenticated() && isPollCreator(pollId);

      // Votes Subcollection (Example - this approach is for storing each vote as a document)
      // Path: /polls/{pollId}/votes/{userId}
      // This makes it easy to check if a user has voted.
      match /votes/{userId} {
        // A user can only create their own vote document
        allow create: if isAuthenticated() && isOwner(userId)
                      && !pollDeadlinePassed(pollId) // Cannot vote if deadline passed
                      && !exists(/databases/$(database)/documents/polls/$(pollId)/votes/$(request.auth.uid)) // Not voted yet
                      && request.resource.data.optionId is string // Vote must have an optionId
                      && request.resource.data.votedAt == request.time;
                      // Add validation that optionId is one of the poll's options

        // Users cannot read individual votes (to prevent knowing who voted for what easily)
        allow read: if false; // Or: if isAuthenticated() && isOwner(userId);
        // Users cannot update or delete their votes once cast directly
        allow update: if false;
        allow delete: if false;
      }
    }

    // Comments
    // Path: /comments/{commentId}
    match /comments/{commentId} {
      // Anyone can read comments
      allow read: if true;

      // Authenticated users can create comments
      allow create: if isAuthenticated()
                    && request.resource.data.user.id == request.auth.uid
                    && request.resource.data.pollId is string // Must link to a poll
                    // && exists(/databases/$(database)/documents/polls/$(request.resource.data.pollId)) // Ensure poll exists
                    && request.resource.data.text is string && request.resource.data.text.size() > 0 && request.resource.data.text.size() < 1000
                    && request.resource.data.createdAt == request.time;

      // Only the author can update their comment (e.g., edit text)
      allow update: if isAuthenticated() && isCommentAuthor(commentId)
                    && request.resource.data.text is string && request.resource.data.text.size() > 0 && request.resource.data.text.size() < 1000
                    && request.resource.data.createdAt == resource.data.createdAt; // Cannot change original timestamp

      // Only the author can delete their comment
      allow delete: if isAuthenticated() && isCommentAuthor(commentId);
    }

    // Stripe Customers (Example, if you store customer info - usually sensitive, handle with care)
    // Path: /stripe_customers/{userId}
    // This is a common pattern if you sync Stripe customer IDs to Firestore.
    // Access to this should be VERY restricted, usually only backend/admin.
    match /stripe_customers/{userId} {
        allow read, write: if false; // Default deny for client access. Manage via Cloud Functions.
        // If you need user to read their own customer ID for some reason:
        // allow read: if isAuthenticated() && isOwner(userId);
    }

    // Pledges (if you track them in a separate collection)
    // Path: /pledges/{pledgeId}
    match /pledges/{pledgeId} {
        // Example rules:
        // Allow owner to read their pledges
        // allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
        // Generally created and updated by backend after Stripe events
        allow create, update, delete: if false;
    }

  }
}

    