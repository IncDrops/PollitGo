
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function getIncomingData() {
      return request.resource.data;
    }

    function getExistingData() {
      return resource.data;
    }

    // Users Collection: User documents are keyed by user.uid
    match /users/{userId} {
      // Anyone can read user profiles
      allow read: if true;

      // An authenticated user can create their own profile document if it doesn't exist.
      // - The document ID {userId} must match their auth uid.
      // - The 'id' field in the document must also match their auth uid.
      // - Required fields (username, email, avatarUrl, createdAt, pollitPointsBalance) must be present and valid.
      allow create: if isAuthenticated() && isOwner(userId)
                    && getIncomingData().id == userId
                    && getIncomingData().username is string && getIncomingData().username.size() >= 3 && getIncomingData().username.size() <= 20
                    && getIncomingData().email == request.auth.token.email
                    && getIncomingData().avatarUrl is string // Validate URL format if possible, or trust client for now
                    && getIncomingData().createdAt is timestamp && getIncomingData().createdAt == request.time
                    && getIncomingData().pollitPointsBalance == 0;

      // An authenticated user can update their own profile.
      // - Cannot change 'id', 'email', 'createdAt'.
      // - Can update 'username', 'avatarUrl'.
      // - 'pollitPointsBalance' should ideally be updated by server functions, not directly by client.
      allow update: if isAuthenticated() && isOwner(userId)
                    && getIncomingData().id == getExistingData().id
                    && getIncomingData().email == getExistingData().email
                    && getIncomingData().createdAt == getExistingData().createdAt
                    && getIncomingData().username is string && getIncomingData().username.size() >= 3 && getIncomingData().username.size() <= 20
                    && getIncomingData().avatarUrl is string
                    && (getIncomingData().pollitPointsBalance == getExistingData().pollitPointsBalance || 지속적인_서버_업데이트_필요); // Placeholder to remind server update is better for points

      // Users cannot delete their own accounts via client (usually handled by backend/admin)
      allow delete: if false;
    }

    // Polls Collection: Polls documents are keyed by a unique poll ID
    match /polls/{pollId} {
      // Anyone can read polls
      allow read: if true;

      // Authenticated users can create polls
      // - Creator ID in the document must match the authenticated user's UID.
      // - Validate required fields (question, options, deadline, etc.) and their types.
      // - Initial votes, likes, commentsCount should be 0.
      allow create: if isAuthenticated()
                    && isOwner(getIncomingData().creator.id)
                    && getIncomingData().creator.name is string
                    && getIncomingData().creator.avatarUrl is string
                    && getIncomingData().creator.username is string
                    && getIncomingData().question is string && getIncomingData().question.size() > 0 && getIncomingData().question.size() <= 500
                    && getIncomingData().options is list && getIncomingData().options.size() >= 2 && getIncomingData().options.size() <= 4
                    && (forall o in getIncomingData().options :
                        o.id is string && o.text is string && o.text.size() > 0 && o.text.size() <= 365 && o.votes == 0
                        && (o.imageUrl == null || (o.imageUrl is string && o.imageUrl.matches('^https?://.*')))
                        && (o.videoUrl == null || (o.videoUrl is string && o.videoUrl.matches('^https?://.*')))
                        && (o.affiliateLink == null || (o.affiliateLink is string && o.affiliateLink.matches('^https?://.*')))
                    )
                    && getIncomingData().deadline is timestamp && getIncomingData().deadline > request.time
                    && getIncomingData().createdAt is timestamp && getIncomingData().createdAt == request.time
                    && getIncomingData().likes == 0
                    && getIncomingData().totalVotes == 0
                    && getIncomingData().commentsCount == 0
                    && (getIncomingData().isVoted == false || getIncomingData().isVoted == null) // Explicitly false or null
                    && getIncomingData().votedOptionId == null
                    && (getIncomingData().pledgeAmount == null || (getIncomingData().pledgeAmount is number && getIncomingData().pledgeAmount > 0))
                    && (getIncomingData().pledgeOutcome == null || getIncomingData().pledgeOutcome == 'pending')
                    && (getIncomingData().tipCount == null || getIncomingData().tipCount == 0)
                    && getIncomingData().isSpicy is bool
                    && (getIncomingData().imageUrls == null || (getIncomingData().imageUrls is list && getIncomingData().imageUrls.size() <= 4 && (forall url in getIncomingData().imageUrls : url is string && url.matches('^https?://.*'))))
                    && (getIncomingData().imageKeywords == null || (getIncomingData().imageKeywords is list && (forall kw in getIncomingData().imageKeywords : kw is string && kw.size() <= 30)))
                    && (getIncomingData().videoUrl == null || (getIncomingData().videoUrl is string && getIncomingData().videoUrl.matches('^https?://.*')));

      // Rules for updating polls (voting, liking, creator updates)
      allow update: if isAuthenticated() && (
                      // Case 1: Voting on a poll
                      (
                        !isOwner(getExistingData().creator.id) // Voter is not the creator
                        && getExistingData().deadline > request.time // Deadline not passed
                        && getExistingData().isVoted == false // User has not voted before on this client instance (client manages this)
                        && getIncomingData().isVoted == true
                        && getIncomingData().votedOptionId is string
                        && getIncomingData().options.size() == getExistingData().options.size() // Options list size cannot change
                        // Total votes must increment by 1
                        && getIncomingData().totalVotes == getExistingData().totalVotes + 1
                        // Find the voted option and ensure its vote count increments by 1
                        && (exists i in 0..(getIncomingData().options.size() - 1) :
                            getIncomingData().options[i].id == getIncomingData().votedOptionId &&
                            getIncomingData().options[i].votes == getExistingData().options[i].votes + 1 &&
                            // Ensure other options' vote counts and content remain unchanged
                            (forall j in 0..(getIncomingData().options.size() - 1) :
                                (i == j) || (
                                  getIncomingData().options[j].votes == getExistingData().options[j].votes &&
                                  getIncomingData().options[j].text == getExistingData().options[j].text &&
                                  getIncomingData().options[j].imageUrl == getExistingData().options[j].imageUrl &&
                                  getIncomingData().options[j].videoUrl == getExistingData().options[j].videoUrl &&
                                  getIncomingData().options[j].affiliateLink == getExistingData().options[j].affiliateLink
                                )
                            )
                        )
                        // Ensure other critical poll fields are not changed by a voter
                        && getIncomingData().question == getExistingData().question
                        && getIncomingData().creator.id == getExistingData().creator.id
                        && getIncomingData().deadline == getExistingData().deadline
                        && getIncomingData().createdAt == getExistingData().createdAt
                        && getIncomingData().likes == getExistingData().likes // Likes handled separately
                        && getIncomingData().commentsCount == getExistingData().commentsCount // Comments handled separately
                        && getIncomingData().pledgeAmount == getExistingData().pledgeAmount
                        && getIncomingData().pledgeOutcome == getExistingData().pledgeOutcome
                        && getIncomingData().tipCount == getExistingData().tipCount
                        && getIncomingData().isSpicy == getExistingData().isSpicy
                        && getIncomingData().imageUrls == getExistingData().imageUrls
                        && getIncomingData().videoUrl == getExistingData().videoUrl
                      )
                      // Case 2: Liking/unliking a poll (simple increment/decrement of likes)
                      || (
                        (getIncomingData().likes == getExistingData().likes + 1 || getIncomingData().likes == getExistingData().likes - 1) &&
                        // Ensure only 'likes' and potentially 'isVoted' fields change, others remain same
                        getIncomingData().question == getExistingData().question &&
                        getIncomingData().creator.id == getExistingData().creator.id &&
                        getIncomingData().options == getExistingData().options && // Options array content must not change
                        getIncomingData().deadline == getExistingData().deadline &&
                        getIncomingData().createdAt == getExistingData().createdAt &&
                        getIncomingData().totalVotes == getExistingData().totalVotes &&
                        getIncomingData().commentsCount == getExistingData().commentsCount &&
                        // isVoted and votedOptionId might be set if user voted before liking
                        getIncomingData().isVoted == getExistingData().isVoted &&
                        getIncomingData().votedOptionId == getExistingData().votedOptionId &&
                        getIncomingData().pledgeAmount == getExistingData().pledgeAmount &&
                        getIncomingData().pledgeOutcome == getExistingData().pledgeOutcome &&
                        getIncomingData().tipCount == getExistingData().tipCount &&
                        getIncomingData().isSpicy == getExistingData().isSpicy &&
                        getIncomingData().imageUrls == getExistingData().imageUrls &&
                        getIncomingData().videoUrl == getExistingData().videoUrl
                      )
                      // Case 3: Poll creator updating pledge outcome
                      || (
                        isOwner(getExistingData().creator.id) // Only the creator
                        && getExistingData().deadline <= request.time // Deadline must have passed
                        && getIncomingData().pledgeOutcome in ['accepted', 'tipped_crowd'] // Valid outcomes
                        && getIncomingData().pledgeOutcome != getExistingData().pledgeOutcome // Must be a change
                        // Ensure other critical fields are not changed by this action
                        && getIncomingData().question == getExistingData().question &&
                        getIncomingData().creator.id == getExistingData().creator.id &&
                        getIncomingData().options == getExistingData().options &&
                        getIncomingData().deadline == getExistingData().deadline &&
                        getIncomingData().createdAt == getExistingData().createdAt &&
                        getIncomingData().likes == getExistingData().likes &&
                        getIncomingData().totalVotes == getExistingData().totalVotes &&
                        getIncomingData().commentsCount == getExistingData().commentsCount &&
                        getIncomingData().isVoted == getExistingData().isVoted &&
                        getIncomingData().votedOptionId == getExistingData().votedOptionId &&
                        getIncomingData().pledgeAmount == getExistingData().pledgeAmount &&
                        getIncomingData().tipCount == getExistingData().tipCount &&
                        getIncomingData().isSpicy == getExistingData().isSpicy &&
                        getIncomingData().imageUrls == getExistingData().imageUrls &&
                        getIncomingData().videoUrl == getExistingData().videoUrl
                      )
                      // Add other specific update scenarios if needed (e.g., creator editing poll text before votes)
                    );

      // Only the creator can delete their poll
      allow delete: if isAuthenticated() && isOwner(getExistingData().creator.id);

      // Comments subcollection for each poll
      match /comments/{commentId} {
        // Anyone can read comments
        allow read: if true;

        // Authenticated users can create comments
        // - 'user.id' in the comment must match the authenticated user's UID.
        // - The pollId of the comment (if stored in the comment doc) should match the parent {pollId}.
        // - Validate text and createdAt.
        allow create: if isAuthenticated()
                      && isOwner(getIncomingData().user.id)
                      // Validate that the user object being written is consistent with the authenticated user
                      && getIncomingData().user.name is string
                      && getIncomingData().user.avatarUrl is string
                      && getIncomingData().user.username is string
                      // Assuming the comment document also stores the pollId to link back
                      // && getIncomingData().pollId == pollId // This check is implicit due to subcollection path
                      && getIncomingData().text is string && getIncomingData().text.size() > 0 && getIncomingData().text.size() <= 1000
                      && getIncomingData().createdAt is timestamp && getIncomingData().createdAt == request.time;

        // Only the author can update their comment's text.
        allow update: if isAuthenticated() && isOwner(getExistingData().user.id)
                      && getIncomingData().user.id == getExistingData().user.id // User ID cannot change
                      && getIncomingData().text is string && getIncomingData().text.size() > 0 && getIncomingData().text.size() <= 1000
                      && getIncomingData().createdAt == getExistingData().createdAt; // Cannot change createdAt

        // Only the author can delete their comment
        allow delete: if isAuthenticated() && isOwner(getExistingData().user.id);
      }
    }
  }
}

    