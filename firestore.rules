
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Deny all reads and writes by default
    match /{document=**} {
      allow read, write: if false;
    }

    // Users collection
    // - Anyone can read public user profiles
    // - Authenticated users can create their own profile document (e.g., on signup)
    // - Authenticated users can only update or delete their own profile
    match /users/{userId} {
      allow read: if true;
      allow create: if request.auth != null && request.auth.uid == userId
                      && request.resource.data.id == userId // Ensure they are setting their own ID
                      && request.resource.data.username is string
                      && request.resource.data.username.size() >= 3 && request.resource.data.username.size() <= 20
                      && request.resource.data.email == request.auth.token.email
                      && request.resource.data.createdAt is timestamp
                      && request.resource.data.pollitPointsBalance == 0;
      allow update: if request.auth != null && request.auth.uid == userId
                      // Allow updating specific fields like username, avatarUrl, but not email or createdAt directly by user
                      && !(request.resource.data.email != resource.data.email)
                      && !(request.resource.data.createdAt != resource.data.createdAt)
                      && !(request.resource.data.pollitPointsBalance != resource.data.pollitPointsBalance); // Points managed by server
      allow delete: if false; // Generally, users should not delete their own profiles directly, handle via admin/server
    }

    // Polls collection
    // - Anyone can read polls
    // - Authenticated users can create polls with validation
    // - Poll creators can update their own polls (e.g., pledgeOutcome, or non-critical fields before votes)
    // - Poll creators can delete their own polls (if allowed by app logic, e.g., before votes or if archived)
    match /polls/{pollId} {
      allow read: if true;
      allow create: if request.auth != null
                      && request.resource.data.creator.id == request.auth.uid
                      && request.resource.data.question is string && request.resource.data.question.size() > 0 && request.resource.data.question.size() <= 500
                      && request.resource.data.options is list && request.resource.data.options.size() >= 2 && request.resource.data.options.size() <= 4
                      && request.resource.data.options[0].text is string // Basic check, deeper validation needed for all options
                      && request.resource.data.deadline is timestamp && request.resource.data.deadline > request.time
                      && request.resource.data.createdAt == request.time
                      && request.resource.data.totalVotes == 0
                      && request.resource.data.likes == 0
                      && request.resource.data.commentsCount == 0
                      && (request.resource.data.pledgeAmount == null || (request.resource.data.pledgeAmount is number && request.resource.data.pledgeAmount >= 0.50))
                      && (request.resource.data.pledgeOutcome == null || request.resource.data.pledgeOutcome == 'pending')
                      && request.resource.data.isSpicy is bool;

      allow update: if request.auth != null && request.auth.uid == resource.data.creator.id
                      // Allow creator to update pledgeOutcome after deadline
                      && (
                        (request.resource.data.pledgeOutcome != resource.data.pledgeOutcome && resource.data.deadline <= request.time)
                        // Add other updatable fields here with appropriate conditions
                        // e.g., if no votes yet, allow question edit: && resource.data.totalVotes == 0 && request.resource.data.question != resource.data.question
                      )
                      // Prevent changing critical immutable fields
                      && request.resource.data.creator.id == resource.data.creator.id
                      && request.resource.data.createdAt == resource.data.createdAt;


      // Rules for voting (subcollection or part of poll document - this assumes votes are tallied in the poll document)
      // This is a simplified representation for updating vote counts.
      // A more robust system might use a subcollection for individual votes to prevent double voting.
      // For this example, we'll assume client updates `isVoted`, `votedOptionId`, `totalVotes`, and option `votes`.
      // This requires careful client-side logic and can be prone to race conditions if not handled well.
      // A server-side function for voting is often more robust.
      allow update: if request.auth != null
                      // Check if the user is voting (isVoted field is changing from false to true)
                      && request.resource.data.isVoted == true && resource.data.isVoted == false
                      // Check if the poll is still active
                      && resource.data.deadline > request.time
                      // Check if totalVotes and option votes are being incremented correctly by 1
                      && request.resource.data.totalVotes == resource.data.totalVotes + 1
                      && request.resource.data.options.size() == resource.data.options.size()
                      && ( // Ensure only the voted option's count increases by 1
                           request.resource.data.options[request.resource.data.options.indexOf(
                             request.resource.data.options.filter(opt => opt.id == request.resource.data.votedOptionId)[0]
                           )].votes == resource.data.options[resource.data.options.indexOf(
                             resource.data.options.filter(opt => opt.id == request.resource.data.votedOptionId)[0]
                           )].votes + 1
                         )
                      // Ensure other option votes remain unchanged
                      && request.resource.data.options.filter(opt => opt.id != request.resource.data.votedOptionId).every(
                           updatedOpt => updatedOpt.votes == resource.data.options.filter(originalOpt => originalOpt.id == updatedOpt.id)[0].votes
                         )
                      // Check that likes, commentsCount, creator, question, createdAt are not being changed during a vote
                      && request.resource.data.likes == resource.data.likes
                      && request.resource.data.commentsCount == resource.data.commentsCount
                      && request.resource.data.creator.id == resource.data.creator.id
                      && request.resource.data.question == resource.data.question
                      && request.resource.data.createdAt == resource.data.createdAt;


      allow delete: if request.auth != null && request.auth.uid == resource.data.creator.id; // Or more restrictive logic
    }

    // Comments subcollection for each poll
    // - Authenticated users can create comments
    // - Comment authors can update or delete their own comments
    match /polls/{pollId}/comments/{commentId} {
      allow read: if true;
      allow create: if request.auth != null
                      && request.resource.data.user.id == request.auth.uid
                      && request.resource.data.text is string && request.resource.data.text.size() > 0 && request.resource.data.text.size() <= 1000
                      && request.resource.data.createdAt == request.time;
      allow update: if request.auth != null && request.auth.uid == resource.data.user.id
                      && request.resource.data.text is string && request.resource.data.text.size() > 0 && request.resource.data.text.size() <= 1000
                      // Prevent changing author or original creation time
                      && request.resource.data.user.id == resource.data.user.id
                      && request.resource.data.createdAt == resource.data.createdAt;
      allow delete: if request.auth != null && request.auth.uid == resource.data.user.id;
    }

    // Example for a 'votes' subcollection if you choose that pattern for more robust voting
    // match /polls/{pollId}/votes/{userId} {
    //   allow read: if request.auth != null && request.auth.uid == userId; // User can read their own vote
    //   allow create: if request.auth != null && request.auth.uid == userId // User can cast their vote if poll active
    //                   && exists(/databases/$(database)/documents/polls/$(pollId))
    //                   && get(/databases/$(database)/documents/polls/$(pollId)).data.deadline > request.time;
    //   // Generally, votes are not updated or deleted once cast.
    //   allow update, delete: if false;
    // }

  }
}

    